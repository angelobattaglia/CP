{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome Contributors!","text":"<p>For full documentation visit mkdocs.org. And, also,  mkdocs material.</p>"},{"location":"#workflow-to-contribute","title":"Workflow to contribute","text":""},{"location":"#docs-to-help-contribute-better","title":"docs to help contribute better","text":"<ul> <li>general: logo and icons</li> <li>general: color palette</li> <li>general: navigation</li> <li>handling code blocks</li> <li>formatting</li> <li>Mathematics</li> </ul>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<p>Modify or add content to the markdown files in the docs/ directory:</p> <pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"CPLibrary/","title":"The <code>#include&lt;bits/stdc++.h&gt;</code> library","text":"<p>. Basic Data Structures with bits/stdc++: initializing them, filling them and searching in them</p> <p>Example using vector&lt;&gt; of tuples&lt;&gt; and giving it a name and a size and filling it with datas from the stdIO</p>"},{"location":"CPLibrary/#a-little-note","title":".. a little note ..","text":"<p>Use of <code>#include&lt;bits/stdc++.h&gt;</code>: This header is convenient but not standard C++. It's widely used in competitive programming for efficiency but might not be portable or optimal for production environments. For broader compatibility, consider including only the specific headers you need (e.g., <code>&lt;iostream&gt;</code>, <code>&lt;vector&gt;</code>, <code>&lt;tuple&gt;</code>).</p>"},{"location":"CPLibrary/#initializing-a-data-structure","title":"Initializing a data structure","text":"<pre><code>    // Inserting the n from standard input\n    cin &gt;&gt; n;\n\n    // Vector to store tuples, each containing three integers\n    vector&lt;tuple&lt;int, int, int&gt;&gt; problems(n);\n\n    for(int i = 0; i &lt; n; ++i) {\n        int a, b, c;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;  // Read the three numbers\n        problems[i] = make_tuple(a, b, c);  // Store them in the vector as a tuple\n    }\n</code></pre> <ul> <li> <p>The line vector&gt; problems(n); in C++ declares a vector that stores elements of type tuple. Let's break it down for clarity: <li> <p>vector&lt;&gt;: This part declares a variable as a vector. Vectors are part of the C++ Standard Template Library (STL) and are dynamic arrays that can grow or shrink in size.</p> </li> <li> <p>&gt;: This specifies the type of elements that the vector will store. In this case, it's a tuple containing three int elements. A tuple is a fixed-size collection of heterogeneous values. Here, the tuple is used to store three integers, which can represent any three related values you need (like the solutions from three participants in your problem). <li> <p>problems(n): This initializes the vector named problems with n elements. Each element of the vector is a tuple initialized with default values. Since the tuple contains integers, each integer in the tuple will be initialized to zero. The value n is the number of problems (or tuples) you intend to store, which was read from the input just before.</p> </li>"},{"location":"CPLibrary/#cycling-through-a-data-structure","title":"Cycling through a data structure","text":"<p>Unpacking the elements of a tuple into separate values with <code>std::tie</code>. The <code>std::tie</code> function in C++ is a utility that creates a tuple of lvalue references to its arguments. It's commonly used to unpack the elements of a tuple into separate variables. Here's a detailed explanation of how <code>std::tie</code> works and how it's used for unpacking tuples:</p>"},{"location":"CPLibrary/#basics-of-stdtie","title":"Basics of <code>std::tie</code>","text":"<ul> <li>Syntax: <code>auto tie_var = std::tie(var1, var2, var3, ...);</code></li> <li>Purpose: <code>std::tie</code> is used to create a tuple of references to variables passed to it. This is particularly useful for unpacking the values from another tuple or for tieing multiple variables together for comparison or assignment purposes.</li> </ul>"},{"location":"CPLibrary/#unpacking-a-tuple-with-stdtie","title":"Unpacking a Tuple with <code>std::tie</code>","text":"<p>When you have a tuple, say <code>std::tuple&lt;int, int, int&gt; myTuple</code>, containing three integers, you can unpack the values stored in <code>myTuple</code> into separate variables <code>a</code>, <code>b</code>, and <code>c</code> like this:</p> <pre><code>int a, b, c;\nstd::tie(a, b, c) = myTuple;\n</code></pre> <p>Here's what happens in this process:</p> <ol> <li> <p>Creating References: <code>std::tie(a, b, c)</code> creates a temporary tuple of references to <code>a</code>, <code>b</code>, and <code>c</code>. These references are essentially aliases to the original variables <code>a</code>, <code>b</code>, and <code>c</code>.</p> </li> <li> <p>Assignment: The <code>operator=</code> of the tuple is then called to assign the values from <code>myTuple</code> to the temporary tuple created by <code>std::tie</code>. This operation assigns each element of <code>myTuple</code> to the corresponding reference in the temporary tuple, effectively unpacking the values into <code>a</code>, <code>b</code>, and <code>c</code>.</p> </li> <li> <p>Result: After the assignment, <code>a</code>, <code>b</code>, and <code>c</code> hold the values that were stored in <code>myTuple</code>.</p> </li> </ol>"},{"location":"CPLibrary/#practical-uses","title":"Practical Uses","text":"<ul> <li> <p>Unpacking: The primary use of <code>std::tie</code> is to unpack the elements of a tuple into separate variables, as shown above. This is especially handy when functions return tuples and you want to work with individual elements.</p> </li> <li> <p>Tieing for Comparison: You can use <code>std::tie</code> to compare multiple variables in a single statement by creating a tuple of references to those variables. For example, <code>std::tie(a, b) &lt; std::tie(x, y)</code> compares <code>a</code> with <code>x</code> and <code>b</code> with <code>y</code> in lexicographical order.</p> </li> <li> <p>Ignoring Elements: Sometimes, you might want to unpack only certain elements of a tuple and ignore others. C++17 introduced <code>std::ignore</code> for this purpose, allowing you to unpack selected elements while discarding others:</p> </li> </ul> <p><code>cpp   std::tuple&lt;int, double, char&gt; myTuple = std::make_tuple(1, 2.0, 'a');   int myInt;   char myChar;   std::tie(myInt, std::ignore, myChar) = myTuple;  // Unpacks 1 into myInt and 'a' into myChar, ignoring the double.</code></p>"},{"location":"CPLibrary/#conclusion","title":"Conclusion","text":"<p><code>std::tie</code> is a versatile tool in C++ for working with tuples, enabling easy unpacking of tuple elements into separate variables, facilitating comparisons, and allowing selective unpacking with the help of <code>std::ignore</code>. Its ability to create a tuple of references makes it a powerful utility for managing and manipulating grouped variables.</p> <p>In the context of C++ and the use of <code>std::tie</code> for unpacking tuples, the term \"reference\" refers to a reference type, which is one of the fundamental types in C++. A reference serves as an alias for another variable, allowing two variable names to refer to the same memory location. Here's a more detailed explanation:</p>"},{"location":"CPLibrary/#passing-this-data-structure-to-a-function","title":"Passing this data structure to a function","text":""},{"location":"CPLibrary/#by-reference","title":"By Reference","text":""},{"location":"CPLibrary/#by-value","title":"By Value","text":""},{"location":"CPLibrary/#strings","title":"Strings","text":"<p>The string class is a part of the C++ Standard Library (included through the <code>&lt;string&gt;</code> header, which is itself included in <code>&lt;bits/stdc++.h&gt;</code>), and it provides a more complex and flexible way to work with text compared to the traditional C-style character arrays.</p> <p>Here is a basic example of how you might use the string class in C++:</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    string x = \"hello\";\n    cout &lt;&lt; x &lt;&lt; endl; // Output: hello\n    return 0;\n}\n</code></pre>"},{"location":"CPLibrary/#algorithms","title":"Algorithms","text":"<p>In competitive programming, the choice of sorting algorithm is often driven by efficiency and ease of implementation within the constraints of the problem. The C++ Standard Library, which is included when you use <code>#include&lt;bits/stdc++.h&gt;</code>, provides robust sorting functionalities that are highly optimized for general use cases. Specifically, the <code>std::sort</code> function is a highly efficient sorting algorithm that usually outperforms most manually implemented sorting algorithms in terms of both time and effort.</p>"},{"location":"CPLibrary/#stdsort","title":"std::sort","text":"<p>The <code>std::sort</code> function, found in the <code>&lt;algorithm&gt;</code> header (which is included in <code>&lt;bits/stdc++.h&gt;</code>), is typically a hybrid sorting algorithm. It is a combination of QuickSort, HeapSort, and InsertionSort, known as Introsort. Starting with QuickSort and switching to HeapSort when the recursion depth exceeds a level based on the number of elements being sorted, and using InsertionSort for small partitions, <code>std::sort</code> is optimized for various scenarios and generally offers excellent performance:</p> <ul> <li>Best for most cases in competitive programming: Because it's highly optimized and requires only a few lines of code to implement.</li> <li>Time Complexity: O(n log n) on average, which is sufficient for a large set of problems.</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\nint main() {\n    vector&lt;int&gt; nums = {4, 1, 3, 9, 7};\n    sort(nums.begin(), nums.end()); // Ascending order\n\n    // For descending order:\n    // sort(nums.begin(), nums.end(), greater&lt;int&gt;());\n\n    for(int num : nums) {\n        cout &lt;&lt; num &lt;&lt; \" \";\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"CPLibrary/#when-to-implement-your-own-sorting-algorithm","title":"When to Implement Your Own Sorting Algorithm","text":"<p>Implementing your own sorting algorithm (like QuickSort or MergeSort) is rarely necessary unless:</p> <ol> <li>The problem specifically requires it: Sometimes, a problem might ask you to implement a particular sorting algorithm without using library functions.</li> <li>Custom sorting logic that <code>std::sort</code> cannot easily handle: Even then, you can often use <code>std::sort</code> with a custom comparator.</li> <li>Educational purposes or practicing: Implementing sorting algorithms can be a great learning exercise.</li> </ol>"},{"location":"CPLibrary/#conclusion_1","title":"Conclusion","text":"<p>For the vast majority of competitive programming problems, you should use <code>std::sort</code> for sorting needs due to its simplicity and efficiency. It is not reliant on the <code>&lt;bits/stdc++.h&gt;</code> module per se, but this module includes the <code>&lt;algorithm&gt;</code> header, which contains <code>std::sort</code>. The need to manually implement a sorting algorithm like QuickSort or BubbleSort is quite rare in competitive programming scenarios. Always consider the problem's constraints and requirements, but remember that standard library functions are your friends for most sorting tasks.</p>"},{"location":"matrices/","title":"Working with matrices","text":"<p>Modeling a matrix in a low-level language like C++ requires a clear understanding of both the data structure you wish to represent and the memory management capabilities of the language. For a matrix, which is essentially a two-dimensional array, you have several options in C++ depending on the specifics of your application, such as fixed-size matrices, dynamically allocated matrices, and matrices using Standard Template Library (STL) containers. I'll outline a few methods here, focusing on their implementation and the trade-offs they entail.</p>"},{"location":"matrices/#1-fixed-size-matrix-using-native-arrays","title":"1. Fixed-Size Matrix Using Native Arrays","text":"<p>For small, compile-time fixed-size matrices, you can simply use a two-dimensional array.</p> <pre><code>const int ROWS = 5; // Number of rows\nconst int COLS = 5; // Number of columns\nint matrix[ROWS][COLS];\n</code></pre> <p>This method is straightforward and efficient but lacks flexibility since the size is determined at compile-time.</p>"},{"location":"matrices/#2-dynamically-allocated-matrix","title":"2. Dynamically Allocated Matrix","text":"<p>For matrices where the size is not known until runtime, you can dynamically allocate memory.</p> <pre><code>int** matrix;\nint rows = 5; // Number of rows\nint cols = 5; // Number of columns\n\n// Allocate memory\nmatrix = new int*[rows];\nfor(int i = 0; i &lt; rows; ++i)\n    matrix[i] = new int[cols];\n\n// Don't forget to deallocate memory to avoid memory leaks\nfor(int i = 0; i &lt; rows; ++i)\n    delete[] matrix[i];\ndelete[] matrix;\n</code></pre> <p>This approach is more flexible but requires careful memory management to avoid leaks.</p>"},{"location":"matrices/#3-matrix-using-stl-vectors","title":"3. Matrix Using STL Vectors","text":"<p>The STL's <code>std::vector</code> class can be used to create a dynamically resizable matrix without manual memory management.</p> <pre><code>#include &lt;vector&gt;\n\nstd::vector&lt;std::vector&lt;int&gt;&gt; matrix;\nint rows = 5; // Number of rows\nint cols = 5; // Number of columns\n\n// Resize and initialize\nmatrix.resize(rows);\nfor(auto&amp; row : matrix)\n    row.resize(cols);\n</code></pre> <p>This method combines flexibility with the convenience of automatic memory management, making it suitable for many applications.</p>"},{"location":"matrices/#4-matrix-class","title":"4. Matrix Class","text":"<p>For more complex applications, you might want to encapsulate matrix operations within a class.</p> <pre><code>#include &lt;vector&gt;\n\nclass Matrix {\npublic:\n    std::vector&lt;std::vector&lt;int&gt;&gt; data;\n\n    Matrix(int rows, int cols) : data(rows, std::vector&lt;int&gt;(cols)) {}\n\n    int&amp; at(int row, int col) {\n        return data[row][col];\n    }\n\n    // Add other matrix operations like addition, multiplication, etc.\n};\n</code></pre> <p>This approach offers the most flexibility, allowing you to define methods for matrix operations, and it makes your code cleaner and more maintainable.</p>"},{"location":"matrices/#5-bit-representations","title":"5. Bit Representations","text":"<p>For matrices composed of bits (e.g., binary matrices), you might opt for a more compact representation using <code>std::bitset</code> or bitfields within integers, depending on your matrix's size and operations you need to perform.</p> <pre><code>#include &lt;bitset&gt;\n\nconst int SIZE = 5; // Assuming a square matrix for simplicity\nstd::bitset&lt;SIZE*SIZE&gt; bitMatrix;\n\n// Accessing and setting bits require calculating the index\nbool getBit(int row, int col) {\n    return bitMatrix.test(row * SIZE + col);\n}\n\nvoid setBit(int row, int col, bool value) {\n    bitMatrix.set(row * SIZE + col, value);\n}\n</code></pre> <p>This method is highly space-efficient for binary data but can be more complex to manage due to the manual indexing.</p>"},{"location":"matrices/#conclusion","title":"Conclusion","text":"<p>The best approach depends on your specific requirements, such as the matrix size, whether its dimensions are known at compile-time or runtime, and the operations you need to perform on it. For most general purposes, using <code>std::vector</code> provides a good balance between ease of use and flexibility. For more specialized applications, particularly those requiring optimization for space or speed, you might consider the other approaches mentioned.</p>"},{"location":"reference/","title":"Reference","text":"<ul> <li> <p>Definition: A reference in C++ is created by placing an ampersand (<code>&amp;</code>) before a variable name during its declaration. Once a reference is initialized with a variable, it becomes an alternative name for that variable.</p> </li> <li> <p>Syntax: <code>Type&amp; referenceName = originalVariable;</code></p> </li> </ul>"},{"location":"reference/#characteristics-of-references","title":"Characteristics of References","text":"<ul> <li> <p>Alias: A reference acts as an alias for another variable. Any operation performed on the reference affects the original variable because both the reference and the original variable refer to the same memory location.</p> </li> <li> <p>Initialization: A reference must be initialized when it is declared. Unlike pointers, references cannot be uninitialized or \"null.\"</p> </li> <li> <p>Immutability: Once a reference is bound to a variable, it cannot be made to refer to a different variable later. In this aspect, references are less flexible than pointers.</p> </li> <li> <p>Indirection: References provide a level of indirection, similar to pointers, but with a syntax that is more like that of a regular variable. There's no need to use a dereference operator (<code>*</code>) to access the value.</p> </li> </ul>"},{"location":"reference/#references-in-the-context-of-stdtie","title":"References in the Context of <code>std::tie</code>","text":"<p>When <code>std::tie</code> is used to unpack a tuple, it creates a temporary tuple of references to the variables provided as arguments. Each element of this temporary tuple is a reference to the corresponding variable outside the tuple. This allows the values within another tuple to be copied directly into the variables referred to by the temporary tuple created by <code>std::tie</code>.</p> <p>For example:</p> <pre><code>int a, b, c;\nstd::tuple&lt;int, int, int&gt; myTuple = std::make_tuple(10, 20, 30);\n\n// Creates a temporary tuple of references to a, b, and c\nstd::tie(a, b, c) = myTuple;\n</code></pre> <p>In this code:</p> <ul> <li><code>std::tie(a, b, c)</code> creates a tuple where each element is a reference to <code>a</code>, <code>b</code>, and <code>c</code>, respectively.</li> <li>The assignment operation <code>= myTuple</code> unpacks the values from <code>myTuple</code> and assigns them to <code>a</code>, <code>b</code>, and <code>c</code> through the references. Since these are references, <code>a</code>, <code>b</code>, and <code>c</code> are directly modified to hold the values from <code>myTuple</code>.</li> </ul>"},{"location":"reference/#conclusion","title":"Conclusion","text":"<p>In summary, a \"reference\" in this context is a powerful feature of C++ that allows <code>std::tie</code> to unpack values from a tuple directly into existing variables by creating a tuple of references. This mechanism provides a convenient and efficient way to work with grouped data, such as tuples, by directly linking the data to individual variables.</p>"},{"location":"reference/#passing-by-value-passing-by-reference","title":"Passing by Value, Passing by Reference","text":"<p>In C++ and other programming languages, \"passing by value\" and \"passing by reference\" are two different ways to pass arguments to functions. These methods determine how the function interacts with the values passed to it and can affect the function's behavior, performance, and side effects.</p>"},{"location":"reference/#passing-by-value","title":"Passing by Value","text":"<p>When an argument is passed by value to a function, the function receives a copy of the argument's value. This means that any modifications made to the argument inside the function do not affect the original variable outside the function. Here are the key points:</p> <ul> <li>Copy: The function works on a copy of the argument's value.</li> <li>No Side Effects: Changes to the parameter within the function do not affect the original argument.</li> <li>Performance: Passing by value can be less efficient for large data structures or objects, as making a copy can be expensive in terms of memory and processing time.</li> </ul> <p>Example of passing by value:</p> <pre><code>void function(int x) {  // x is a copy of the argument passed\n    x = 10;  // Modifying x does not affect the original variable\n}\n\nint main() {\n    int a = 5;\n    function(a);  // a is passed by value\n    // a will still be 5 here\n}\n</code></pre>"},{"location":"reference/#passing-by-reference","title":"Passing by Reference","text":"<p>Passing by reference means that the function receives a reference (an alias) to the actual argument, rather than a copy. Any modifications made to the parameter inside the function will affect the original argument outside the function, since both the parameter and the argument refer to the same memory location. Here are the key points:</p> <ul> <li>Reference: The function operates on the actual argument, not a copy.</li> <li>Side Effects: Changes to the parameter within the function affect the original argument.</li> <li>Efficiency: Passing by reference is generally more efficient for large data structures or objects since it avoids the overhead of copying.</li> </ul> <p>References in C++ are created using the ampersand (<code>&amp;</code>) symbol in the function parameter list:</p> <pre><code>void function(int&amp; x) {  // x is a reference to the argument passed\n    x = 10;  // Modifying x will also modify the original variable\n}\n\nint main() {\n    int a = 5;\n    function(a);  // a is passed by reference\n    // a will be 10 here, as it was modified inside the function\n}\n</code></pre>"},{"location":"reference/#passing-by-pointer","title":"Passing by Pointer","text":"<p>C++ also allows \"passing by pointer,\" which is similar to passing by reference in that the function can modify the original argument. A pointer is passed to the function, which points to the memory address of the argument. This method also allows the function to modify the original argument:</p> <pre><code>void function(int* x) {  // x is a pointer to the argument passed\n    *x = 10;  // Modifying the value pointed to by x will modify the original variable\n}\n\nint main() {\n    int a = 5;\n    function(&amp;a);  // The address of a is passed\n    // a will be 10 here, as it was modified inside the function\n}\n</code></pre>"},{"location":"reference/#conclusion_1","title":"Conclusion","text":"<p>Choosing between passing by value and passing by reference (or by pointer) depends on the intended behavior of the function and the efficiency considerations. Passing by value ensures isolation and protects the original data from unintended modifications, while passing by reference or by pointer allows the function to modify the original data and can be more efficient for large objects.</p> <p>In C++, understanding the concepts of lvalues and rvalues is crucial for grasping how expressions are evaluated, how values are assigned, and how resources are managed, especially with the advent of move semantics in C++11. These terms distinguish expressions by their identities and their temporariness, which in turn influences their usability in different contexts.</p>"},{"location":"reference/#lvalues","title":"Lvalues:","text":"<ul> <li> <p>Definition: An \"lvalue\" (locator value) refers to an expression that points to a specific memory location. Lvalues have an identifiable address in memory, meaning they represent objects that persist beyond a single expression. You can think of an lvalue as something that could appear on the left-hand side of an assignment.</p> </li> <li> <p>Characteristics:</p> <ul> <li>Lvalues have a name and represent a memory location that can be accessed.</li> <li>They can be used on both the left and right sides of an assignment operator.</li> <li>You can take the address of an lvalue using the address-of operator (<code>&amp;</code>).</li> </ul> </li> <li> <p>Examples: Variables, dereferenced pointers, array elements, and references are typical lvalues.</p> </li> </ul> <pre><code>int x = 5; // x is an lvalue\nx = 10;    // Valid because x is an lvalue\nint* p = &amp;x; // Valid because &amp;x is the address of lvalue\n</code></pre>"},{"location":"reference/#rvalues","title":"Rvalues:","text":"<ul> <li> <p>Definition: An \"rvalue\" (right value) refers to a temporary value that does not have a permanent address in memory. Rvalues are typically used on the right-hand side of an assignment and represent values that are not associated with a specific location in memory.</p> </li> <li> <p>Characteristics:</p> <ul> <li>Rvalues are temporary and cannot be assigned to directly.</li> <li>They cannot appear on the left-hand side of an assignment operator (with the exception of rvalue references in C++11 and beyond).</li> <li>An rvalue can be moved from to initialize or assign an lvalue, enabling move semantics.</li> </ul> </li> <li> <p>Examples: Literal constants, non-lvalue expressions resulting from arithmetic operations, function returns that are not references, and temporary objects are rvalues.</p> </li> </ul> <pre><code>int a = 5 + 2; // 5 + 2 is an rvalue\nint b = a;     // a is treated as an rvalue when used in this expression\n</code></pre>"},{"location":"reference/#rvalue-references-and-move-semantics","title":"Rvalue References and Move Semantics:","text":"<p>Introduced in C++11, rvalue references allow developers to distinguish between code that operates on lvalues and rvalues. This distinction enables the implementation of move semantics, which can significantly improve performance by allowing resources (like dynamically allocated memory) to be transferred from temporary objects (rvalues) to other objects, rather than copying.</p> <ul> <li>Rvalue Reference: Defined using <code>&amp;&amp;</code>, it binds only to rvalues.</li> </ul> <pre><code>void process(std::string&amp;&amp; s) { /*...*/ }\n</code></pre> <ul> <li>Move Semantics: Allows the resources of an rvalue to be \"moved\" into another object, avoiding a deep copy and improving efficiency.</li> </ul> <pre><code>std::string str1 = \"Hello\";\nstd::string str2 = std::move(str1); // Moves str1's data to str2\n</code></pre> <p>In this example, <code>std::move</code> casts <code>str1</code> to an rvalue reference, which allows <code>str2</code>'s constructor to transfer the data from <code>str1</code> without copying, leaving <code>str1</code> in a valid but unspecified state.</p>"},{"location":"reference/#conclusion_2","title":"Conclusion","text":"<p>Understanding lvalues and rvalues is fundamental for effective C++ programming, particularly when dealing with resource management, overloading functions or operators for efficiency, and utilizing modern C++ features like move semantics and rvalue references. These concepts help in optimizing performance and writing clear, efficient code that takes full advantage of the language's capabilities.</p>"},{"location":"reference/#example-da-rivedere-e-formattare-bene","title":"Example ( da Rivedere e formattare bene )","text":""},{"location":"reference/#original-issue-in-code","title":"Original Issue in Code","text":"<p>Let's analyse <code>solve</code> function, you attempted to redefine a vector with the same name as a parameter passed to the function:</p> <pre><code>void solve(int n, vector&lt;tuple&lt;int, int, int&gt;&gt; problems) {\n    int count = 0;\n\n    vector&lt;tuple&lt;int, int, int&gt;&gt; problems(n);\n    ...\n}\n</code></pre> <p>This approach introduced a problem known as \"variable shadowing.\" Variable shadowing occurs when a variable declared within a certain scope (e.g., a block of code) has the same name as a variable declared in an outer scope. In this case, the inner scope variable \"shadows\" the outer one, making the outer variable inaccessible within the inner scope. </p>"},{"location":"reference/#implications","title":"Implications","text":"<p>In the context of your function, declaring a new <code>vector&lt;tuple&lt;int, int, int&gt;&gt; problems(n);</code> inside the <code>solve</code> function shadows the <code>problems</code> parameter that the function receives. This means that any reference to <code>problems</code> within the <code>solve</code> function refers to this newly declared vector, not the parameter passed to the function. This can lead to several issues: - Unintended Behavior: Since the new <code>problems</code> vector is initialized without values (simply with a size of <code>n</code>), it doesn't contain the expected problem data. This means operations intended to be performed on the actual problem data will not work as expected. - Redundant Data Handling: By attempting to reinitialize and repopulate the <code>problems</code> vector within the <code>solve</code> function, the code redundantly handles data that should have been passed directly to the function, leading to inefficiency. - Increased Memory Usage: Declaring a new vector unnecessarily increases memory usage, especially if the vector is large.</p>"},{"location":"reference/#correction-strategy","title":"Correction Strategy","text":"<p>To correct this issue, you should avoid redeclaring the <code>problems</code> vector within the <code>solve</code> function. Instead, use the vector passed as a parameter directly. This ensures that the function operates on the correct data set provided to it and avoids the issues mentioned above. If the function intends to modify the vector in a way that should not affect the caller, it could accept the vector by value (causing it to work on a copy) or create a local copy explicitly if needed for local computations, though neither of these approaches is necessary for this particular problem.</p> <p>Thus, the corrected version of the <code>solve</code> function does not include a new declaration of <code>problems</code> and instead works directly with the vector passed to it:</p> <pre><code>void solve(int n, const vector&lt;tuple&lt;int, int, int&gt;&gt;&amp; problems) {\n    int count = 0;\n    for(int i = 0; i &lt; n; i++) {\n        int a, b, c;\n        tie(a, b, c) = problems[i];\n        if(a + b + c &gt;= 2) {\n            count++;\n        }\n    }\n    cout &lt;&lt; count &lt;&lt; \"\\n\";\n}\n</code></pre> <p>This approach correctly uses the <code>problems</code> vector that contains the problem data, ensuring that the function operates on the intended data without unnecessary redundancy or memory usage. Certainly, the usage of <code>const vector&lt;tuple&lt;int, int, int&gt;&gt;&amp; problems</code> in the parameter list of a function is an illustrative example of employing both const-correctness and reference semantics in C++. Let's dissect this construct to understand its significance and advantages in detail:</p>"},{"location":"reference/#const-correctness","title":"Const Correctness","text":"<ul> <li>Const: The <code>const</code> keyword, when applied to a function parameter, indicates that the function does not and cannot modify the object that the parameter refers to. This is a way to enforce immutability within the function, ensuring that the data passed to it remains unchanged throughout the function's execution. In the context of <code>const vector&lt;tuple&lt;int, int, int&gt;&gt;&amp;</code>, it guarantees that the vector, as well as the tuples contained within it, will not be modified by the <code>solve</code> function. This is particularly important for maintaining data integrity, especially when passing data structures that should not be altered by the function.</li> </ul>"},{"location":"reference/#reference-semantics","title":"Reference Semantics","text":"<ul> <li>&amp; (Reference): Using the ampersand (<code>&amp;</code>) to pass the vector by reference means that the function operates on the original vector passed to it, rather than on a copy of the vector. This is crucial for efficiency, especially with large data structures, as it avoids the overhead associated with copying the entire vector and its contents (which could be substantial). However, without <code>const</code>, using a reference would also allow the function to modify the vector, potentially leading to unintended side effects. By combining <code>&amp;</code> with <code>const</code>, you get the efficiency benefits of passing by reference while also ensuring the safety of not altering the data.</li> </ul>"},{"location":"reference/#together-const-reference","title":"Together: Const Reference","text":"<ul> <li><code>const vector&lt;tuple&lt;int, int, int&gt;&gt;&amp;</code>: This declaration harmoniously combines the principles of const correctness and reference semantics. It signifies that the function receives a reference to a vector, promoting efficiency by avoiding unnecessary copying. Simultaneously, it guarantees that the function cannot modify the vector or its elements, ensuring data integrity and preventing side effects. This practice is widely recommended in C++ for passing complex data structures to functions when the intention is to read from the data structure without modifying it.</li> </ul>"},{"location":"reference/#advantages","title":"Advantages","text":"<ol> <li>Performance: By avoiding unnecessary copies of the vector, this method significantly reduces the memory footprint and the computational overhead, which is especially beneficial when dealing with large data structures.</li> <li>Safety: It ensures that the function does not inadvertently change the input data, making the code safer and easier to reason about, particularly in large and complex codebases.</li> <li>Clarity and Intent: Declaring parameters as <code>const</code> references clearly communicates the function's intent to not modify the input data, making the code more readable and maintainable.</li> </ol> <p>In summary, the use of <code>const vector&lt;tuple&lt;int, int, int&gt;&gt;&amp; problems</code> as a function parameter is a best practice in C++ that combines efficiency with safety. It allows functions to efficiently read from large or complex data structures without the risk of modifying them, ensuring that the code is both performant and reliable.</p>"},{"location":"starter/","title":"Starting out","text":"<ul> <li>e-maxx.ru</li> <li>cp-algorithms</li> <li>Competitive Programmer's Handbook</li> <li>C++ reference</li> </ul>"},{"location":"starter/#basic-template-for-cp","title":"Basic template for CP","text":"<p>This is a starting template</p> <pre><code>#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n\n// Fast I/O\n#define FAST_IO ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n// Function to solve the problem\nvoid solve(int n) {\n}\n\nint main() {\n    FAST_IO;\n\n    /*\n        Number of test cases\n    */\n    int t;\n    cin &gt;&gt; t;\n\n    /*\n        The loop uses the condition t--, which is a post-decrement operation. This means the loop checks t to see if it's \n        greater than 0, thereby entering the loop if it is. Inside the loop, after checking the condition, it decrements \n        t by 1. The loop will continue to execute as long as t is greater than 0. Like a countdown.\n    */\n    while(t--) {\n        solve();\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"starter/#cli-flags-for-the-compiler","title":"CLI flags for the compiler","text":"<p>Testing Locally: It's a good practice to test your code locally with the -std=c++17 flag to ensure it's compatible with C++17 standards.</p> <p>Testing your code locally before submitting it to an online judge like Codeforces is an essential practice in competitive programming. It helps ensure that your solution behaves as expected, both in terms of correctness and performance, under different conditions. Local testing can simulate the judge's environment to some extent, catching potential issues early. Here's a brief overview focusing on the use of G++ and its flags for local testing.</p>"},{"location":"starter/#why-test-locally","title":"Why Test Locally?","text":"<ol> <li>Immediate Feedback: Testing locally provides instant feedback on errors, allowing for quicker iterations and debugging.</li> <li>Environment Control: You have full control over the testing environment, including the compiler, flags, and input/output redirection.</li> <li>Stress Testing: You can automate testing against large or random datasets to ensure the robustness and efficiency of your solution.</li> <li>Understanding Limits: Local testing helps you understand how your solution behaves under time and memory constraints.</li> </ol>"},{"location":"starter/#using-g-flags-for-local-testing","title":"Using G++ Flags for Local Testing","text":"<p>When compiling your C++ code with G++, you can specify various flags to control the compilation process. Here are some common flags relevant to competitive programming:</p> <ul> <li><code>-std=c++17</code> (or another version): Specifies the C++ standard to use. Adjust this based on the standard you're targeting (e.g., <code>-std=c++11</code>, <code>-std=c++14</code>, <code>-std=c++17</code>).</li> <li><code>-Wall</code>: Enables all the warnings about constructions that some users consider questionable, and that are easy to avoid.</li> <li><code>-Wextra</code>: Enables additional warnings not covered by <code>-Wall</code>.</li> <li><code>-O2</code>: Optimizes the code for more speed. This is useful to ensure your code runs fast enough but be aware it can make debugging harder.</li> <li><code>-g</code>: Generates debug information in your executable, which is helpful for debugging with tools like GDB.</li> <li><code>-DLOCAL</code>: Defines a preprocessor macro <code>LOCAL</code> that can be used to enable sections of code only when testing locally. Useful for debug prints or to read inputs from files.</li> </ul>"},{"location":"starter/#example-of-local-compilation-and-testing","title":"Example of Local Compilation and Testing","text":"<p>To compile your program with C++17 support, optimizations, and all warnings enabled, you could use a command like:</p> <pre><code>g++ -std=c++17 -Wall -Wextra -O2 your_program.cpp -o your_program\n</code></pre> <p>Then, to run your program with an input file <code>input.txt</code> and output the result to <code>output.txt</code>, you could use:</p> <pre><code>./your_program &lt; input.txt &gt; output.txt\n</code></pre> <p>For debugging or development purposes, you might compile with:</p> <pre><code>g++ -std=c++17 -Wall -Wextra -g -DLOCAL your_program.cpp -o your_program\n</code></pre> <p>This setup allows you to include debugging information and conditionally compile sections of your code meant only for local testing, such as:</p> <pre><code>#ifdef LOCAL\nstd::cerr &lt;&lt; \"Debug information\";\n#endif\n</code></pre> <p>Local testing, combined with the strategic use of G++ flags, is a powerful approach to developing, debugging, and refining your competitive programming solutions. It'd be great also to use a Makefile to manage the build of the script.</p>"}]}